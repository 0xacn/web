service cloud.firestore {
	match /databases/{database}/documents {
		match /users/{uid} {
			allow read, write: if signedInWith(uid)
			match /name {
				allow read, write: if signedInWith(uid) && newData().isString() && newData() != ''
			}
			match /email {
				allow read, write: if signedInWith(uid) && newData().isString() && newData() != ''
			}
			match /decks/{deckId} {
				allow read, write: if signedInWith(uid)
				match /name {
					allow read, write: if signedInWith(uid) && newData().isString() && newData() != ''
				}
				match /count {
					allow create: if signedInWith(uid) && newData() === 0
				}
				match /mastered {
					allow create: if signedInWith(uid) && newData() === 0
				}
				match /cards/{cardId} {
					match /count {
						allow create: if signedInWith(uid) && newData() === 0
					}
					match /correct {
						allow create: if signedInWith(uid) && newData() === 0
					}
					match /streak {
						allow create: if signedInWith(uid) && newData() === 0
					}
					match /last {
						allow create: if signedInWith(uid)
					}
					match /next {
						allow create: if signedInWith(uid)
					}
					match /history/{historyId} {
						allow create: if signedInWith(uid)
						match /date {
							allow create: if signedInWith(uid)
						}
						match /next {
							allow create: if signedInWith(uid)
						}
						match /correct {
							allow create: if signedInWith(uid) && newData().isBoolean()
						}
						match /elapsed {
							allow create: if signedInWith(uid) && newData().isNumber()
						}
					}
				}
			}
		}
		match /decks/{deckId} {
			allow read: if authId() === deckId.owner || !deckId.permissions.authId().isEmpty() || deckId.public
			allow write: if authId() === deckId.owner || deckId.permissions.authId().role === 'editor'
			match /name {
				allow write: if (authId() === deckId.owner || deckId.permissions.authId().role === 'editor') && newData().isString() && newData() != ''
			}
			match /description {
				allow write: if (authId() === deckId.owner || deckId.permissions.authId().role === 'editor') && newData().isString() && newData() != ''
			}
			match /public {
				allow write: if authId() === deckId.owner && newData().isBoolean()
			}
			match /count {
				allow create: if signedIn() && newData() === 0
			}
			match /creator {
				match /id {
					allow create: if signedIn() && newData().isString() && newData() != ''
				}
				match /name {
					allow create: if signedIn() && newData().isString() && newData() != ''
				}
			}
			match /owner {
				allow write: if authId() === oldData() && newData().isString() && newData() != ''
			}
			match /permissions/{userId} {
				allow write: if authId() === deckId.owner
				match /name {
					allow write: if authId() === deckId.owner && newData().isString() && newData() != ''
				}
				match /email {
					allow write: if authId() === deckId.owner && newData().isString() && newData() != ''
				}
				match /role {
					allow write: if authId() === deckId.owner && (newData() === 'viewer' || newData() === 'editor')
				}
			}
			match /cards/{cardId} {
				allow write: if authId() === deckId.owner
				match /front {
					allow write: if authId() === deckId.owner && newData().isString() && newData() != ''
				}
				match /back {
					allow write: if authId() === deckId.owner && newData().isString() && newData() != ''
				}
			}
		}

		function authId() {
			return request.auth.uid
		}

		function signedIn() {
			return request.auth != null
		}

		function signedInWith(uid) {
			return authId() === uid
		}

		function oldData() {
			return resource.data
		}

		function newData() {
			return request.resource.data
		}
	}
}